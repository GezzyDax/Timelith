name: Release

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]')"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: get_latest_tag
        run: |
          # Get the latest tag, or use 0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Determine version bump
        id: version_bump
        run: |
          # Get commit messages since last tag
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"

          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            # First release
            NEW_VERSION="v0.1.0"
            BUMP_TYPE="minor"
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s")

            # Check for breaking changes or major keywords
            if echo "$COMMITS" | grep -qiE "BREAKING CHANGE|major:"; then
              BUMP_TYPE="major"
            # Check for features or minor keywords
            elif echo "$COMMITS" | grep -qiE "^feat|^feature|minor:"; then
              BUMP_TYPE="minor"
            # Default to patch for fixes and other changes
            else
              BUMP_TYPE="patch"
            fi

            # Parse current version
            CURRENT_VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

            # Bump version
            case $BUMP_TYPE in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION (bump type: $BUMP_TYPE)"

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          echo "# Release $NEW_VERSION" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "## Changes" >> CHANGELOG.md
          echo "" >> CHANGELOG.md

          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            echo "- Initial release" >> CHANGELOG.md
          else
            # Group commits by type
            git log ${LATEST_TAG}..HEAD --pretty=format:"%s" | while read line; do
              if echo "$line" | grep -qiE "^feat|^feature"; then
                echo "- âœ¨ $line" >> CHANGELOG.md
              elif echo "$line" | grep -qiE "^fix"; then
                echo "- ðŸ› $line" >> CHANGELOG.md
              elif echo "$line" | grep -qiE "^docs"; then
                echo "- ðŸ“š $line" >> CHANGELOG.md
              elif echo "$line" | grep -qiE "^refactor"; then
                echo "- â™»ï¸ $line" >> CHANGELOG.md
              elif echo "$line" | grep -qiE "^test"; then
                echo "- ðŸ§ª $line" >> CHANGELOG.md
              elif echo "$line" | grep -qiE "^chore|^ci"; then
                echo "- ðŸ”§ $line" >> CHANGELOG.md
              else
                echo "- $line" >> CHANGELOG.md
              fi
            done
          fi

          echo "" >> CHANGELOG.md
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...${NEW_VERSION}" >> CHANGELOG.md

          # Set output for release notes
          CHANGELOG_CONTENT=$(cat CHANGELOG.md)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update version files
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"
          VERSION_NUMBER=${NEW_VERSION#v}

          # Update Go version if version.go exists
          if [ -f "go-backend/internal/version/version.go" ]; then
            sed -i "s/Version = \".*\"/Version = \"$VERSION_NUMBER\"/" go-backend/internal/version/version.go
          else
            # Create version file
            mkdir -p go-backend/internal/version
            cat > go-backend/internal/version/version.go << EOF
          package version

          // Version is the current version of the application
          const Version = "$VERSION_NUMBER"
          EOF
          fi

          # Update package.json version
          cd web-ui
          npm version $VERSION_NUMBER --no-git-tag-version
          cd ..

      - name: Commit version updates
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add -A
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]" || echo "No changes to commit"
          git push origin main || echo "No changes to push"

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag -a $NEW_VERSION -m "Release $NEW_VERSION"
          git push origin $NEW_VERSION

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version_bump.outputs.new_version }}
          release_name: Release ${{ steps.version_bump.outputs.new_version }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false

      - name: Build and push Docker images
        if: success()
        run: |
          NEW_VERSION="${{ steps.version_bump.outputs.new_version }}"
          VERSION_NUMBER=${NEW_VERSION#v}

          echo "ðŸ“¦ Building Docker images with version $VERSION_NUMBER"

          # Note: Add Docker registry login here if you want to push images
          # docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}

          # Build images with version tags
          docker build -t timelith-backend:$VERSION_NUMBER -t timelith-backend:latest ./go-backend
          docker build -t timelith-web:$VERSION_NUMBER -t timelith-web:latest ./web-ui

          echo "âœ… Docker images built successfully"
          echo "To push to registry, uncomment docker push commands in workflow"

          # Uncomment to push to Docker registry:
          # docker push timelith-backend:$VERSION_NUMBER
          # docker push timelith-backend:latest
          # docker push timelith-web:$VERSION_NUMBER
          # docker push timelith-web:latest
